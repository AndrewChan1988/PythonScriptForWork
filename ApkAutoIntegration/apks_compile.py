# coding=utf-8

import shutil
import os
import sys
import subprocess
import datetime

try:
    import xml.etree.cElementTree as cET
except ImportError:
    import xml.etree.ElementTree as cET

sdk_location = '''## This file is automatically generated by Android Studio.
# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
#
# This file should *NOT* be checked into Version Control Systems,
# as it contains information specific to your local configuration.
#
# Location of the SDK. This is only used by Gradle.
# For customization when using a Version Control System, please read the
# header note.
sdk.dir=D:\\android-sdk
'''

lint_option = '''
    lintOptions {
        abortOnError false
    }
'''

build_time = '''
def buildTime() {
    def df = new SimpleDateFormat("yyMMdd.HHmmss")
    df.setTimeZone(TimeZone.getDefault())
    return df.format(new Date())
}
'''

configurations = {
    "sdk-folder": r"D:\android-sdk",
    "sdk-platform-folder": r"${sdk-folder}\platforms\android-23",
    "sdk-tools": r"${sdk-folder}\tools",
    "sdk-platform-tools": r"${sdk-folder}\build-tools\\23.0.3",
    "aapt": r"${sdk-platform-tools}\aapt",
    "aidl": r"${sdk-platform-tools}\aidl",
    "dx": r"${sdk-platform-tools}\dx.bat",
    "jarsigner": r"C:\Program Files\Java\jdk1.8.0_77\bin\jarsigner",
    "Javacpath": r"C:\Program Files\Java\jdk1.8.0_77\bin\javac",
    "android-jar": r"${sdk-platform-folder}\android.jar",
    "framework-aidl": r"${sdk-platform-folder}\framework.aidl"
}

depends = {
    "debug": "package",
    "release": "package-release"
}


# Initialize the gradle of project
def gradle_init(dir):
    settings_gradle_path = dir + "\Settings.gradle"   # path of Settings.gradle
    local_properties_path = dir + "\local.properties" # path of local.properties' path

    # Get all modules' name from reading the Setting.gradle
    with open(settings_gradle_path, 'r') as f:
        module_name = f.readline()
    module_name = module_name.replace("'", '').replace(":", '').replace(",", '').split()[1:]

    # modify the build.gradles of modules in project, add list_content to those build.gradles
    for i in range(0, len(module_name)):
        module_build_gradle_path = dir + "\\" + module_name[i] + "\\build.gradle"
        print(module_build_gradle_path)
        list_content = []
        new_content = ''

        list_content.append("import java.text.SimpleDateFormat\n")
        # 在Gradle.build中添加new_content和build_time内容
        with open(module_build_gradle_path, 'r') as f:
            for line in f.readlines():
                list_content.append(line)
        for content in list_content:
            if "versionName" in content:
                version_name = content.split()[1].strip('"')
                version_name_format = '        versionName "' + version_name + '({0})"\n'.format(date_format2)
                new_content += version_name_format
                continue
            if "defaultConfig {" in content:
                new_content = new_content + lint_option + content
                continue
            new_content = new_content + content
        with open(module_build_gradle_path, 'r+') as f:
            f.writelines(new_content)


def ant_init(pdir):
    build_xml = "D:\APK_BUILD\\" + prj_name + "\\build.xml"
    build_common_xml = "D:\APK_BUILD\\" + prj_name + "\\build_common.xml"
    if os.path.exists(build_xml) and os.path.exists(build_common_xml):
        shutil.copy(build_common_xml, pdir + "\\build_common.xml")
        shutil.copy(build_xml, pdir + "\\build.xml")
    else:
        return 1
    return 0


# Gradle Compilation
def gradle(prj_dir):
    print("工作目录：", os.getcwd())
    command = 'D: && cd ' + prj_dir + ' && gradle clean build'
    print("开始用gralde编译apk")
    code = do_command(command, False)
    return code


def ant(prj_dir):
    command = "ant release"
    print("开始用ant编译apk")
    code = do_command(command, False)
    return code


# execute command
def do_command(cmd, need_result=True):
    print('执行命令: ', cmd)
    out = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    if need_result:
        out.wait()
        result = out.communicate()[0].decode().strip()
        print(result)
        return result, out.returncode
    else:
        while out.poll() is None:
            s = out.stdout.readline()
            if s != b'':
                if "ant" in cmd:
                    print(s.decode('cp936').strip())
                else:
                    print(s.decode('utf-8').strip())
        return out.returncode


# sign apk
def sign_apk(prj_path, sign_type):
    find_apk_cmd = "for /r " + prj_path + " %i in (*.apk) do @echo %i"
    apk_path = do_command(find_apk_cmd)
    apk_path_list = apk_path[0].split()
    status = 1
    for s in apk_path_list:
        if "unsigned" in s:
            os.chdir(sign_apk_path)
            apk_dir = os.path.dirname(s)
            apk_name = os.path.basename(s).replace("unsigned", "signed")
            sign_apk_cmd = "signapk.jar " + sign_type + ".x509.pem " + sign_type + ".pk8 " + s + " " + apk_dir + "\\" + apk_name
            status = do_command(sign_apk_cmd, False)
    return status


# update code
def code_update(pdir):
    print("同步代码!!!!")

    if os.path.exists(pdir) and os.listdir(pdir):   # 代码目录存在，并且不为空
        current_branchs = do_command("git branch")[0].replace("* ", "*").replace("\n", ' ').split()
        current_branch = ''
        for i in range(len(current_branchs)):
            if "*" in current_branchs[i]:
                current_branch = current_branchs[i].replace('*', '')
                current_branchs[i] = current_branch
                break

        if current_branch != branch:
            print("分支不一致，切换分支")
            do_command("git reset --hard", False)
            do_command("git clean -xdf", False)
            if branch in current_branchs:
                do_command("git checkout {0}".format(branch), False)
            else:
                do_command("git checkout -b {0} remotes/origin/{0}".format(branch), False)
            do_command("git pull", False)
            do_command("git log --oneline -10", False)
        else:
            print("分支一致，直接更新代码")
            do_command("git reset --hard", False)
            do_command("git clean -xdf", False)
            do_command("git remote update", False)
            do_command("git pull", False)
    else:  # 代码目录不存在，或者存在但是为空
        if not os.path.exists(pdir):
            print("代码目录不存在，创建代码目录：{0}".format(pdir))
            os.makedirs(pdir)
            os.chdir(pdir)
        do_command("git clone ssh://10.250.115.12:29418/APK/" + prj_name + ".git . -b " + branch, False)
        do_command("git pull", False)


def copy_result(out_dir, project_dir, project_name):
    apk_store_path = out_dir + "\\" + date_format1

    # 找出项目目录中的所有apk
    find_apk_cmd = "for /r " + project_dir + " %i in (*.apk) do @echo %i"
    apk_path = do_command(find_apk_cmd)
    apk_path_list = apk_path[0].split()
    # 检查输出目录是否存在，如不存在则创建
    if not os.path.exists(apk_store_path):
        os.makedirs(apk_store_path)
    # 拷贝项目中编译出来的所有apk到输出目录
    if build_tool == "gradle":
        for apk in apk_path_list:
            if "unaligned" in apk:
                pass
            else:
                dir_apk = os.path.dirname(apk)
                apk_oldname = os.path.basename(apk)
                apk_oldname_list = apk_oldname.split('-')
                apk_oldname_list[0] = prj_name
                apk_newname = "-".join(apk_oldname_list)
                os.rename(os.path.join(dir_apk, apk_oldname), os.path.join(dir_apk, apk_newname))
                shutil.copy(os.path.join(dir_apk, apk_newname), apk_store_path)
    else:
        for apk in apk_path_list:
            dir_apk = os.path.dirname(apk)
            apk_oldname = os.path.basename(apk)
            apk_oldname_list = apk_oldname.split('-')
            apk_oldname_list[0] = prj_name
            apk_newname = "-".join(apk_oldname_list)
            os.rename(os.path.join(dir_apk, apk_oldname), os.path.join(dir_apk, apk_newname))
            shutil.copy(os.path.join(dir_apk, apk_newname), apk_store_path)

    print("输出目录为：{0}".format(apk_store_path))


def push_tag():
    print("准备push tag!!!!!!!!!")
    do_command('git tag -m "apkserver_{0}" {0}'.format(date_format1), False)
    do_command("git push -f origin {0}".format(date_format1), False)

if __name__ == '__main__':
    prj_name = sys.argv[1]
    prj_dir = sys.argv[2]
    sign_type = sys.argv[3]
    build_type = sys.argv[4]
    branch = sys.argv[5]
    build_tool = sys.argv[6]
    sign_apk_path = "D:\\functional\SignApk"
    out_directory = "\\\\10.250.115.52\\APK_Test_Version\\" + prj_name + "\\" + build_type + "\\" + branch
    building_txt_path = prj_dir + "\\building.txt"

    date = datetime.datetime.now()
    date_format1 = date.strftime("%Y.%m.%d_%H.%M")      # yy.mm.dd_HHMM格式的日期
    date_format2 = date.strftime("%Y%m%d_%H%M%S")      # yyMMdd.HHmmss格式的日期
    exit_status = 0

    if not os.path.exists(prj_dir):
        os.makedirs(prj_dir)
    
    print('进入项目目录：{0}'.format(prj_dir))
    os.chdir(prj_dir)

    code_update(prj_dir)
    if build_tool == "gradle":
        print("使用gradle编译工具！！！")
        gradle_init(prj_dir)

        os.chdir(prj_dir)
        exitcode = gradle(prj_dir)
        if exitcode == 0:
            print("APK编译成功！！！")
        else:
            print("APK编译失败！！！")
            sys.exit(1)
    else:
        print("使用ant编译工具！！！")
        init_status = ant_init(prj_dir)
        if init_status == 1:
            print("build.xml不存在，请查看")
            sys.exit(2)
        
        exitcode = ant(prj_dir)
        if exitcode == 0:
            print("APK编译成功！！！")
        else:
            print("APK编译失败！！！")
            sys.exit(1)

    os.chdir(prj_dir)
    if sign_type != "NoSign":
        print('正在对apk进行签名，签名类型为：{0}'.format(sign_type))
        exit_status = sign_apk(prj_dir, sign_type)
        if exit_status != 0:
            print("apk签名失败！！！")
            sys.exit(exit_status)
        else:
            print("apk签名成功！！！")
    os.chdir(prj_dir)
    push_tag()
    copy_result(out_directory, prj_dir, prj_name)
